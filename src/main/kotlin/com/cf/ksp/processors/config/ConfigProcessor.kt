package com.cf.ksp.processors.config

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider
import com.google.devtools.ksp.symbol.KSAnnotated
import java.io.File
import org.yaml.snakeyaml.Yaml
import kotlin.collections.get
import kotlin.collections.iterator

class ConfigProcessor : SymbolProcessorProvider {
  override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
    ConfigProcessorImpl(environment.codeGenerator, environment.logger)

  private class ConfigProcessorImpl(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
  ) : SymbolProcessor {
    override fun process(resolver: Resolver): List<KSAnnotated> {
      logger.info("ConfigProcessors started")

      val configPath =
        resolver.getAllFiles().firstOrNull()?.filePath?.split("/src/main/")?.firstOrNull() +
          "/src/main/config"

      val configDir = File(configPath)
      if (!configDir.exists()) {
        logger.warn("⚠️ No 'src/main/config' directory found.")
        return emptyList()
      }

      configDir
        .listFiles { f -> f.extension in setOf("yml", "yaml") }
        ?.forEach {
          try {
            processYaml(it)
          } catch (e: FileAlreadyExistsException) {
            logger.warn("⚠️ Skipping, already generated.")
          }
        }

      return emptyList()
    }

    private fun processYaml(file: File) {
      val data = Yaml().load<Map<String, Any>>(file.inputStream())
      val packageName =
        data["package"]?.toString()?.let { "$it.config" }
          ?: throw Exception("Package name not specified")
      for ((className, configs) in data) {
        if (configs !is Map<*, *>) continue
        val entries = configs.entries.mapNotNull { parseConfigEntry(it.key.toString(), it.value) }
        writeConfigClass("Abstract$className", packageName, entries)
      }
    }

    private fun writeConfigClass(
      className: String,
      packageName: String,
      entries: List<ConfigEntry>,
    ) {
      val file = codeGenerator.createNewFile(Dependencies(false), packageName, className)
      val methods = entries.joinToString("\n\n", transform = ::getMethod)
      file.writer().use { writer ->
        writer.write(
          """
                |// **************************************************
                |//  ⚠️ AUTO-GENERATED FILE - DO NOT MODIFY MANUALLY  ⚠️
                |//  This file was generated by ConfigProcessor.
                |// **************************************************

                |package $packageName
                |
                |abstract class $className {
                |
                |$methods
                |}
                |
                    """
            .trimMargin()
        )
      }
    }

    private fun getMethod(entry: ConfigEntry): String {
      val methodName = getMethodName(entry)
      val methodBody = getMethodBody(entry)
      return "    fun $methodName(): ${entry.type} $methodBody"
    }

    private fun getMethodName(entry: ConfigEntry): String {
      return entry.key
        .split("_")
        .joinToString("") { it.lowercase().replaceFirstChar(Char::uppercase) }
        .replaceFirstChar(Char::lowercase)
    }

    private fun getMethodBody(entry: ConfigEntry): String {
      val defVal =
        when (entry.type) {
          "Int" -> entry.value.toInt()
          "Long" -> entry.value.toLong()
          "Float" -> entry.value.toFloat()
          "Boolean" -> entry.value.toBoolean()
          else -> "\"${entry.value}\""
        }
      if (!entry.overrideEnv) {
        return """{
                    |        return $defVal
                    |    }
                    """
          .trimMargin()
      }
      return """{
                    |        return System.getenv("${entry.key}")?.to${entry.type}() ?: $defVal
                    |    }
                """
        .trimMargin()
    }

    private fun parseConfigEntry(key: String, value: Any?): ConfigEntry? {
      if (value is String) {
        return ConfigEntry(key, "String", value, true)
      }
      if (value !is Map<*, *>) {
        throw Exception("Invalid config entry for key: $key. Expected a Map.")
      }

      val type =
        (value["type"] ?: "String").toString().lowercase().replaceFirstChar { it.uppercase() }
      assert(setOf("String", "Int", "Long", "Float", "Boolean").contains(type))
      val rawValue =
        value["value"]?.toString() ?: throw Exception("Value not specified for key: $key")
      val overrideEnv = (value["overrideEnv"] ?: "true").toString().toBooleanStrictOrNull() == true
      return ConfigEntry(key, type, rawValue, overrideEnv)
    }

    data class ConfigEntry(
      val key: String,
      val type: String,
      val value: String,
      val overrideEnv: Boolean,
    )
  }
}
