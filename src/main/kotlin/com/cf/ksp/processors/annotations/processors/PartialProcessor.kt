package com.cf.ksp.processors.annotations.processors

import com.cf.ksp.processors.annotations.GeneratePartial
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSAnnotation
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.google.devtools.ksp.validate

class PartialProcessor : SymbolProcessorProvider {
  override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
    PartialProcessorImpl(environment.codeGenerator, environment.logger)

  private class PartialProcessorImpl(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
  ) : SymbolProcessor {
    override fun process(resolver: Resolver): List<KSAnnotated> {
      logger.info("üîß Starting PartialProcessor")

      val symbols =
        resolver
          .getSymbolsWithAnnotation(GeneratePartial::class.qualifiedName!!)
          .filterIsInstance<KSClassDeclaration>()
      val deferredSymbols = mutableListOf<KSAnnotated>()
      symbols.forEach { classDeclaration ->
        if (classDeclaration.validate()) {
          logger.info("validates - processing")
          generatePartialClass(classDeclaration)
        } else {
          logger.info("doesn't validate - deferring")
          deferredSymbols.add(classDeclaration)
        }
      }
      return deferredSymbols
    }

    private fun generatePartialClass(classDeclaration: KSClassDeclaration) {
      val packageName = classDeclaration.packageName.asString()
      val className = classDeclaration.simpleName.asString()
      val partialClassName = "Partial$className"

      val annotation =
        classDeclaration.annotations.firstOrNull { it.shortName.asString() == "GeneratePartial" }

      val includeFields =
        annotation?.arguments?.firstOrNull { it.name?.asString() == "include" }?.value as? List<*>
          ?: emptyList<Any>()
      val includedFieldNames = includeFields.filterIsInstance<String>().toSet()

      val properties =
        classDeclaration.getAllProperties().filter {
          includedFieldNames.isEmpty() || it.simpleName.asString() in includedFieldNames
        }

      val diff = includedFieldNames - properties.map { it.simpleName.asString() }.toSet()
      assert(diff.isEmpty()) { "include contains properties ($diff) not in $className" }

      val classAnnotations =
        classDeclaration.annotations
          .filter { it.shortName.asString() != "GeneratePartial" }
          .map { it.annotationType.resolve() }
          .map { it.declaration.simpleName.asString() }
          .map { "@$it" }

      val propertyStrings = properties.map(this::getProperty)
      val imports = getImports(properties, classDeclaration.annotations)

      val file =
        codeGenerator.createNewFile(
          dependencies = Dependencies(false, classDeclaration.containingFile!!),
          packageName = packageName,
          fileName = partialClassName,
        )

      file.writer().use { writer ->
        writer.write(
          """
                    |// **************************************************
                    |//  ‚ö†Ô∏è AUTO-GENERATED FILE - DO NOT MODIFY MANUALLY  ‚ö†Ô∏è
                    |//  This file was generated by PartialProcessor.
                    |// **************************************************

                    |package $packageName

                    |
                    """
            .trimMargin()
        )
        writer.write(imports.sorted().joinToString("\n"))
        writer.write("\nimport javax.annotation.processing.Generated\n\n")
        writer.write(
          """
                    /**
                     * Partial version of [$className].
                     */
                    """
            .trimIndent()
        )
        writer.write(
          "\n@Generated(\"com.cf.ksp.processors.annotations.processors.PartialProcessor\")\n"
        )
        writer.write(classAnnotations.joinToString("\n"))
        writer.write("\ndata class $partialClassName(\n")
        writer.write(propertyStrings.joinToString(",\n"))
        writer.write("\n)\n")
      }
    }

    private fun getImports(
      properties: Sequence<KSPropertyDeclaration>,
      annotations: Sequence<KSAnnotation>,
    ): Set<String> {
      val importDeclarations = buildSet {
        annotations
          .filter { it.shortName.asString() != "GeneratePartial" }
          .forEach { add(it.annotationType.resolve().declaration) }
        properties
          .flatMap { it.annotations }
          .forEach { add(it.annotationType.resolve().declaration) }
        properties.forEach { add(it.type.resolve().declaration) }
      }
      return importDeclarations
        .map { Pair(it.packageName.asString(), it.simpleName.asString()) }
        .filter { it.first != "kotlin" }
        .map { "import ${it.first}.${it.second}" }
        .toSet()
    }

    private fun getProperty(property: KSPropertyDeclaration): String {
      val annotations = property.annotations.map(this::getAnnotations).joinToString("\n    ")
      val name = property.simpleName.asString()
      val type = property.type.resolve().declaration.simpleName.asString()

      val annotationsStr = if (annotations.isNotEmpty()) "    $annotations\n" else ""
      return "$annotationsStr    val $name: $type? = null"
    }

    private fun getAnnotations(annotation: KSAnnotation): String {
      val type = annotation.annotationType.resolve().declaration
      val name = type.simpleName.asString()
      val args =
        annotation.arguments.joinToString(", ") { arg ->
          if (arg.value is String) "\"${arg.value}\"" else arg.value.toString()
        }
      return if (args.isNotBlank()) "@$name($args)" else "@$name"
    }
  }
}
